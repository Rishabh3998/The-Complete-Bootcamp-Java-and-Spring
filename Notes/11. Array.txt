Introduction to Array
=====================

1. Overview
- Fixed-size, ordered collection of elements of the same type.
- Can hold primitives or objects.
- Zero-based indexing.
- Stored as contiguous memory with direct access by index.

2. Declaration, Allocation, Initialization
- Declaration:
    int[] a;
    String[] s;

- Allocation:
    a = new int[5];

- Combined:
    int[] a = new int[5];

- Static initialization:
    int[] b = {1, 2, 3};

- Inline (only at declaration):
    int[] c = new int[] {4,5,6};

- Multidimensional:
    int[][] grid = new int[3][4];
    int[][] ragged = { {1,2}, {3}, {4,5,6} };

3. Default values
- int -> 0, double -> 0.0, boolean -> false, reference types -> null.

4. Size and bounds
- Use length property (not method): a.length
- Accessing invalid index -> ArrayIndexOutOfBoundsException.

5. Iteration
- Traditional for:
    for (int i = 0; i < arr.length; i++) { ... }

- Enhanced for:
    for (int x : arr) { ... }

- Streams:
    Arrays.stream(arr).forEach(...)

6. Array vs List
- Arrays: fixed-size, primitive arrays exist.
- ArrayList: dynamic size, works with objects (autoboxing for primitives), more flexible.

7. Utility methods (java.util.Arrays)
- toString / deepToString
- equals / deepEquals
- sort / parallelSort
- binarySearch
- copyOf / copyOfRange
- fill
- asList (wraps array as fixed-size List)
- stream / parallelStream

Examples:
- Arrays.toString(arr)
- int[] copy = Arrays.copyOf(arr, newSize);
- Arrays.sort(arr);
- Arrays.fill(arr, 42);
- List<Integer> list = Arrays.asList(1,2,3); // fixed size

8. Cloning and copying
- arr.clone() -> shallow copy of array (copies references)
- System.arraycopy(src, srcPos, dest, destPos, length) -> fast copy
- Deep copy requires manual copying for nested arrays or cloning elements.

9. Equality and hashing
- arr.equals(other) -> same reference check (Object.equals)
- Arrays.equals(arr1, arr2) -> element-wise for 1D
- Arrays.deepEquals for nested arrays
- Arrays.hashCode / Arrays.deepHashCode for hashing

10. Covariance and type-safety
- Object[] objs = new String[5]; // allowed (covariant)
- Runtime ArrayStoreException when storing incompatible type:
    Object[] obj = new String[5];
    obj[0] = Integer.valueOf(1); // throws ArrayStoreException

11. Varargs
- Method signature: void m(String... args) -> treats args as String[]
- Varargs are just arrays at runtime.

12. Performance notes
- Fast indexed access.
- Resizing requires copying to a new array (ArrayList does this under the hood).
- Use primitive arrays to avoid boxing/unboxing overhead.

13. Newer API helpers (useful)
- Arrays.setAll(arr, i -> f(i));
- IntStream.range(0, n).map(i -> fn(i)).toArray();
- Arrays.parallelPrefix, Arrays.parallelSetAll for parallel ops.

Short examples
--------------
int[] nums = {1,2,3};
int[] copy = Arrays.copyOf(nums, nums.length + 2); // [1,2,3,0,0]
for (int v : nums) System.out.println(v);
String[] names = new String[] {"Alice","Bob"};
List<String> list = Arrays.asList(names); // fixed-size view

Remember: arrays are simple and efficient for fixed-size collections; prefer collections (ArrayList, etc.) when you need 
dynamic sizing and rich APIs.

14. Jagged Arrays (Ragged Arrays)
- Definition: An array of arrays where sub-arrays can have different lengths.
- In Java: int[][] jagged = new int[3][]; jagged[0] = new int[2]; jagged[1] = new int[4]; jagged[2] = new int[1];
- Memory: Each row is a separate array object; rows need not be contiguous or same size.
- Use cases: Representing irregular grids, triangular matrices, varying-length records (e.g., CSV rows).
- Iteration example:
    for (int i = 0; i < jagged.length; i++) {
        for (int j = 0; j < jagged[i].length; j++) {
            // use jagged[i][j]
        }
    }

15. 3D Arrays
- Definition: An array whose elements are 2D arrays; conceptually a 3D grid (depth × rows × cols).
- Declaration:
    int[][][] cube = new int[depth][rows][cols];
  or ragged: int[][][] ragged = new int[2][][]; ragged[0] = new int[3][4];
- Access: cube[d][r][c]
- Iteration pattern: three nested loops:
    for (int d = 0; d < cube.length; d++) {
        for (int r = 0; r < cube[d].length; r++) {
            for (int c = 0; c < cube[d][r].length; c++) {
                // process cube[d][r][c]
            }
        }
    }
- Use cases: volumetric data, multi-channel images, time-series of matrices.

16. Drawbacks of Arrays
- Fixed size: cannot grow or shrink; resizing requires creating a new array and copying.
- Costly inserts/deletes: middle insert/remove requires shifting elements (O(n)).
- Homogeneous types only: all elements must be of the same declared type; primitives vs objects require care.
- Boxing/unboxing overhead: collections of primitives require wrapper types or specialized classes.
- Shallow copy semantics: clone() copies array structure; object references inside remain shared.
- No rich APIs: arrays lack convenient manipulation methods (Collections provide richer operations).
- Covariance pitfalls: arrays are covariant at runtime (e.g., Object[] = new String[...]) and can throw ArrayStoreException.
- Potential for errors: risk of ArrayIndexOutOfBoundsException when using wrong indices.
- Not ideal for concurrency: not inherently thread-safe when modified by multiple threads.
- Memory considerations: large contiguous arrays may cause fragmentation/large allocation failures; jagged arrays can mitigate
contiguous-size problems.